#!/usr/bin/env python3
"""
TRULY CONTINUOUS ELIZA - SYNCHRONOUS VERSION
No async, no exits, just pure continuous operation
"""

import os
import time
import logging
from datetime import datetime
from github import Github, Auth
import sys

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - ELIZA-CONTINUOUS - %(levelname)s - %(message)s',
    stream=sys.stdout
)

class TrulyContinuousEliza:
    def __init__(self):
        """Initialize truly continuous Eliza"""
        self.github_token = os.getenv('GITHUB_TOKEN')
        self.repo_name = os.getenv('GITHUB_REPO', 'DevGruGold/xmrtnet')
        self.check_interval = int(os.getenv('CHECK_INTERVAL', '300'))
        
        if not self.github_token:
            logging.error("‚ùå GITHUB_TOKEN not set!")
            sys.exit(1)
        
        # Initialize GitHub
        auth = Auth.Token(self.github_token)
        self.github = Github(auth=auth)
        self.repo = self.github.get_repo(self.repo_name)
        
        self.cycle_count = 0
        self.start_time = time.time()
        
        logging.info("ü§ñ TRULY CONTINUOUS ELIZA INITIALIZED")
    
    def create_cycle_proof(self):
        """Create proof that this cycle ran"""
        try:
            uptime_hours = (time.time() - self.start_time) / 3600
            
            proof_content = f"""# ü§ñ ELIZA CYCLE {self.cycle_count} PROOF
**Timestamp:** {datetime.now().isoformat()}
**Cycle Number:** {self.cycle_count}
**Uptime:** {uptime_hours:.2f} hours
**Status:** CONTINUOUS OPERATION ‚úÖ

## Cycle Details
- **Started:** {datetime.now().isoformat()}
- **Platform:** Render.com
- **Process:** Truly Continuous (No Async)
- **Next Cycle:** In {self.check_interval} seconds

## Progress Indicator
If you see cycle numbers increasing (1, 2, 3, 4...), Eliza is working continuously!

Current cycle: **{self.cycle_count}**
Expected next cycle: **{self.cycle_count + 1}**

---
*Generated by truly continuous Eliza - Cycle {self.cycle_count}*
"""
            
            filename = f"ELIZA_CYCLE_{self.cycle_count}_PROOF.md"
            
            self.repo.create_file(
                filename,
                f"ü§ñ Cycle {self.cycle_count} Proof - Continuous Operation",
                proof_content
            )
            
            logging.info(f"‚úÖ Cycle {self.cycle_count} proof created: {filename}")
            return True
            
        except Exception as e:
            logging.error(f"‚ùå Cycle proof creation failed: {e}")
            return False
    
    def safe_sleep(self, total_seconds):
        """Sleep in small chunks with logging to prove we're still alive"""
        logging.info(f"üò¥ Starting {total_seconds} second sleep in 30-second chunks...")
        
        remaining = total_seconds
        chunk_size = 30  # 30-second chunks
        
        while remaining > 0:
            sleep_time = min(chunk_size, remaining)
            
            logging.info(f"‚è∞ Sleeping for {sleep_time} seconds... ({remaining} seconds remaining)")
            time.sleep(sleep_time)
            remaining -= sleep_time
            
            # Prove we're still alive
            if remaining > 0:
                logging.info(f"üíì Still alive! {remaining} seconds left to sleep")
        
        logging.info("‚úÖ Sleep completed - ready for next cycle!")
    
    def run_continuous_forever(self):
        """Run forever with absolutely no exits - synchronous version"""
        logging.info("üöÄ STARTING TRULY CONTINUOUS OPERATION")
        logging.info("üîÑ This version uses NO async/await - pure synchronous operation")
        
        # Initial startup proof
        startup_content = f"""# üöÄ ELIZA TRULY CONTINUOUS STARTUP
**Started:** {datetime.now().isoformat()}
**Version:** Synchronous Continuous
**Platform:** Render.com

## Startup Configuration
- **Check Interval:** {self.check_interval} seconds
- **Repository:** {self.repo_name}
- **Mode:** Truly Continuous (No Async)

## Expected Behavior
- Cycle 1 will start immediately
- After {self.check_interval} seconds, Cycle 2 will start
- This will continue indefinitely: 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí ...

**If you see increasing cycle numbers, the continuous operation is working!**

---
*Truly continuous Eliza startup - {datetime.now().isoformat()}*
"""
        
        try:
            self.repo.create_file(
                f"ELIZA_CONTINUOUS_STARTUP_{datetime.now().strftime('%H%M%S')}.md",
                "üöÄ Truly Continuous Eliza Startup",
                startup_content
            )
            logging.info("‚úÖ Startup proof created")
        except Exception as e:
            logging.error(f"Startup proof error: {e}")
        
        # MAIN CONTINUOUS LOOP - NO ASYNC, NO EXITS
        while True:  # INFINITE LOOP
            try:
                self.cycle_count += 1
                cycle_start_time = time.time()
                
                logging.info("=" * 60)
                logging.info(f"üîÑ STARTING CYCLE {self.cycle_count}")
                logging.info(f"‚è∞ Cycle start time: {datetime.now().isoformat()}")
                logging.info("=" * 60)
                
                # Create proof of this cycle
                proof_success = self.create_cycle_proof()
                
                cycle_duration = time.time() - cycle_start_time
                logging.info(f"‚úÖ CYCLE {self.cycle_count} COMPLETED in {cycle_duration:.1f} seconds")
                logging.info(f"üò¥ Now sleeping for {self.check_interval} seconds before Cycle {self.cycle_count + 1}")
                
                # Sleep with continuous logging to prove we're alive
                self.safe_sleep(self.check_interval)
                
                logging.info(f"üîÑ Sleep completed! Ready to start Cycle {self.cycle_count + 1}")
                
            except KeyboardInterrupt:
                logging.info("üõë Keyboard interrupt received - but we'll continue anyway!")
                time.sleep(10)
                continue
                
            except Exception as e:
                logging.error(f"‚ùå Error in Cycle {self.cycle_count}: {e}")
                logging.info("üîÑ Continuing to next cycle despite error...")
                time.sleep(60)  # Short sleep on error
                # DON'T EXIT - CONTINUE TO NEXT CYCLE

if __name__ == "__main__":
    logging.info("üéØ TRULY CONTINUOUS ELIZA STARTING...")
    eliza = TrulyContinuousEliza()
    eliza.run_continuous_forever()  # This will NEVER return
